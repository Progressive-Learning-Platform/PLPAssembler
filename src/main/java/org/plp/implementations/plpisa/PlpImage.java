package org.plp.implementations.plpisa;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import org.plp.isa.AsmImage;
import org.plp.isa.AsmProgram;
import org.plp.isa.AsmToken;
import org.plp.isa.AsmInstruction;
import org.plp.isa.AsmInstructionDisassembly;
import org.plp.isa.exceptions.AsmAssemblerException;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This will be storing the disassembly of a given {@link PlpProgram}
 * It will have the encoding of the instructions and also intermediate representations
 * like tokens, intermediate instructions, etc
 */
public class PlpImage implements AsmImage {
    private final AsmProgram plpProgram;
    private final Map<String, Map<Integer, List<AsmToken>>> instructionToTokens;
    private final Map<String, Map<Integer, String>> instructionsToIntermediate;
    private final BiMap<AsmInstruction, AsmInstructionDisassembly> instructionEncodingMap;

    /**
     * This will create an image of the given {@link PlpProgram}
     * @param plpProgram {@link PlpProgram} whose image or encoding this represents
     */
    public PlpImage(AsmProgram plpProgram) {
        this.plpProgram = plpProgram;
        instructionToTokens = new HashMap<>();
        instructionsToIntermediate = new HashMap<>();
        instructionEncodingMap = HashBiMap.create();
    }

    /**
     * This will store the {@link PlpToken} of a given instruction line in the program
     * @param asmFileName {@link PlpFile} whose instruction this is
     * @param lineNumber line number of the instruction in the file
     * @param asmTokens actual set of tokens this instruction comprise of
     */
    public void storeInstructionsTokens(String asmFileName, Integer lineNumber, List<AsmToken> asmTokens) {
        if(!instructionToTokens.containsKey(asmFileName)) {
            Map<Integer, List<AsmToken>> lineNumberToTokensMap = new HashMap<>();
            instructionToTokens.put(asmFileName, lineNumberToTokensMap);
        }

        instructionToTokens.get(asmFileName).put(lineNumber, asmTokens);
    }

    /**
     * This will provide the list of tokens generated by lexer for a given instruction
     * @param asmFileName {@link PlpFile} where the instruction belongs
     * @param lineNumber line number of the instruction
     * @return list of {@link PlpToken}s this instruction has
     */
    public List<AsmToken> getInstructionsTokens(String asmFileName, Integer lineNumber) {
        if(instructionToTokens.containsKey(asmFileName) &&
                instructionToTokens.get(asmFileName).containsKey(lineNumber)) {
            return instructionToTokens.get(asmFileName).get(lineNumber);
        }

        // TODO: Throw an exception here
        return null;
    }

    /**
     * This will store the intermediate representation of the given instruction
     * @param asmFileName {@link PlpFile} whose instruction this is
     * @param lineNumber line number of the instruction
     * @param intermediates intermediate representation of the given instruction
     */
    public void storeInstructionsIntermediate(String asmFileName, Integer lineNumber, String intermediates) {
        if(!instructionsToIntermediate.containsKey(asmFileName)) {
            Map<Integer, String> lineNumberToIntermediate = new HashMap<>();
            instructionsToIntermediate.put(asmFileName, lineNumberToIntermediate);
        }

        instructionsToIntermediate.get(asmFileName).put(lineNumber, intermediates);
    }

    /**
     * This will get the intermediate representation of the given instruction
     * @param asmFileName {@link PlpFile} whose instruction this is
     * @param lineNumber line number of the instruction
     * @return intermediate representation of the given instruction
     */
    public String getInstructionsIntermediate(String asmFileName, Integer lineNumber) {
        if(instructionsToIntermediate.containsKey(asmFileName) &&
                instructionsToIntermediate.get(asmFileName).containsKey(lineNumber)) {
            return instructionsToIntermediate.get(asmFileName).get(lineNumber);
        }

        // TODO: Throw an exception here
        return "";
    }

    /**
     * This provides all the disassembly of the instructions which is stored in-memory.
     *
     * @return list of disassembly of the instruction
     */
    @Override
    public List<AsmInstructionDisassembly> getDisassemblyOfInstructions() {
        return null;
    }

    /**
     * Given an instruction,this will provide its corresponding disassembly
     *
     * @param asmInstruction Asm Instruction whose disassembly needs to be obtained
     * @return Disassembly of the instruction
     * @throws AsmAssemblerException if the given instruction is not found in the encoded list
     */
    @Override
    public AsmInstructionDisassembly getDisassemblyOfInstruction(AsmInstruction asmInstruction) {

        if(!instructionEncodingMap.containsKey(asmInstruction)) {
            // TODO: Throw a proper exception
            throw new AsmAssemblerException("There is no instruction which was encoded");
        }

        return instructionEncodingMap.get(asmInstruction);

    }

    /**
     * Given a disassembly, provide the corresponding instruction whose disassembly it is
     *
     * @param asmInstructionDisassembly Disassembly of the instruction
     * @return Assembly instruction of the given disassembly
     * @throws AsmAssemblerException if the given instruction disassembly is not found in the encoded list
     */
    @Override
    public AsmInstruction getInstructionOfDisassembly(AsmInstructionDisassembly asmInstructionDisassembly) {
        if(!this.instructionEncodingMap.inverse().containsKey(asmInstructionDisassembly)) {
            // TODO: Throw a proper exception
            throw new AsmAssemblerException("There is no instruction disassembly which was encoded");
        }

        return this.instructionEncodingMap.inverse().get(asmInstructionDisassembly);
    }

    /**
     * This will store the list of disassembly to in-memory store which are generated
     * from the instructions.
     *
     * @param asmInstruction {@link AsmInstruction} whose disassembly we are adding.
     * @param asmInstructionDisassembly {@link AsmInstructionDisassembly} which is disassembly of the instruction
     *
     */
    @Override
    public void addDisassemblyOfInstruction(AsmInstruction asmInstruction,
                                            AsmInstructionDisassembly asmInstructionDisassembly) {
        this.instructionEncodingMap.put(asmInstruction, asmInstructionDisassembly);
    }

    /**
     * This provides the {@link AsmProgram} whose asm image this is
     *
     * @return Assembly program whose disassembly this is.
     */
    @Override
    public AsmProgram getProgram() {
        return plpProgram;
    }
}
